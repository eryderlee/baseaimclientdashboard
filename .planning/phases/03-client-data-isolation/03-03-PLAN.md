---
phase: 03-client-data-isolation
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/dashboard/layout.tsx
  - app/dashboard/progress/page.tsx
  - app/dashboard/page.tsx
  - components/dashboard/dashboard-overview.tsx
  - components/dashboard/progress-view.tsx
autonomous: false

must_haves:
  truths:
    - "Dashboard layout shows the logged-in user's real name and email from session"
    - "Progress page loads milestones from the database via DAL, not from mock data"
    - "Client user sees only their own milestones on the progress page"
    - "Admin user sees all clients' milestones on the progress page"
    - "Dashboard overview page shows real progress percentage from database milestones"
  artifacts:
    - path: "app/dashboard/layout.tsx"
      provides: "Server component layout that reads real session data"
      contains: "auth"
    - path: "app/dashboard/progress/page.tsx"
      provides: "Server component progress page fetching milestones via DAL"
      contains: "getMilestones"
    - path: "app/dashboard/page.tsx"
      provides: "Dashboard overview using real milestone data for progress display"
      contains: "getMilestones"
  key_links:
    - from: "app/dashboard/layout.tsx"
      to: "lib/auth.ts"
      via: "import { auth } from '@/lib/auth'"
      pattern: "auth\\(\\)"
    - from: "app/dashboard/progress/page.tsx"
      to: "lib/dal.ts"
      via: "import { getMilestones } from '@/lib/dal'"
      pattern: "getMilestones"
    - from: "app/dashboard/page.tsx"
      to: "lib/dal.ts"
      via: "import { getMilestones } from '@/lib/dal'"
      pattern: "getMilestones"
---

<objective>
Wire the dashboard pages to use real authenticated data instead of mock data. The dashboard layout reads the session for user info, and the progress page fetches milestones through the DAL which automatically filters by client.

Purpose: This completes the data isolation chain. After this plan, a logged-in CLIENT user sees only their milestones, and an ADMIN sees all milestones. The mock data era is over for these pages.

Output: Updated dashboard layout (real session), updated progress page (DAL milestones), updated dashboard overview (real progress).
</objective>

<execution_context>
@C:\Users\eryde\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\eryde\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-client-data-isolation/03-RESEARCH.md
@.planning/phases/03-client-data-isolation/03-01-SUMMARY.md

@lib/dal.ts
@lib/auth.ts
@app/dashboard/layout.tsx
@app/dashboard/progress/page.tsx
@app/dashboard/page.tsx
@components/dashboard/milestone-checklist.tsx
@lib/types/milestone.ts
@lib/milestone-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire dashboard layout and overview to real session and milestone data</name>
  <files>app/dashboard/layout.tsx, app/dashboard/page.tsx, components/dashboard/dashboard-overview.tsx</files>
  <action>
1. Update `app/dashboard/layout.tsx`:
   - Remove the mock user object entirely
   - Import `auth` from `@/lib/auth`
   - This is already an async server component (`export default async function DashboardLayout`)
   - Call `const session = await auth()` to get the real session
   - Extract user data: `const user = session?.user ? { name: session.user.name, email: session.user.email, image: null, role: session.user.role } : { name: "Guest", email: "", image: null, role: "CLIENT" }`
   - Pass this user object to `<DashboardNav user={user} />`
   - Keep all existing layout markup (gradient, padding, etc.) exactly as-is
   - Do NOT add verifySession here -- middleware handles the redirect for unauthenticated users, and the layout should just gracefully handle missing session

2. Update `app/dashboard/page.tsx`:
   - This is currently a "use client" component with all mock data. It needs to become a hybrid:
     - Create a server component wrapper that fetches real milestone data via DAL
     - Pass milestones as props to the existing client component (which needs interactivity for chart expand toggle)
   - Approach:
     a. Remove "use client" from the top of page.tsx
     b. Import `getMilestones` from `@/lib/dal`
     c. Import `Milestone` type from `@/lib/types/milestone`
     d. Make the default export an async server component that calls `const milestones = await getMilestones()`
     e. Convert the existing DashboardPage function into a client component named `DashboardClient` in a separate file OR inline the server data fetch and pass milestones down
     f. The simplest approach: Keep page.tsx as server component, move the interactive UI into a new client component `components/dashboard/dashboard-overview.tsx`, pass milestones as serialized props
   - However, to minimize file changes and keep things simple:
     - Convert page.tsx to a server component
     - Move the existing interactive dashboard content to a client component `DashboardClient` within the same file or a new file
     - The server component fetches milestones and passes them as serialized data

   RECOMMENDED APPROACH (cleanest):
   - Create `components/dashboard/dashboard-overview.tsx` as a "use client" component containing all the current dashboard page content (analytics mock data, stat cards, milestones display, activity, etc.)
   - The `app/dashboard/page.tsx` becomes a thin server component that fetches real milestones and passes them
   - For now, the analytics/activity/documents/notifications data stays as mock in the client component (those are Phase 4+ concerns)
   - Only the milestone data gets replaced with real data from DAL

   Implementation for page.tsx (server component):
   ```typescript
   import { getMilestones } from "@/lib/dal"
   import { DashboardOverview } from "@/components/dashboard/dashboard-overview"

   export default async function DashboardPage() {
     const milestones = await getMilestones()

     // Serialize dates for client component (JSON serialization)
     const serializedMilestones = milestones.map(m => ({
       ...m,
       startDate: m.startDate ? new Date(m.startDate).toISOString() : null,
       dueDate: m.dueDate ? new Date(m.dueDate).toISOString() : null,
       completedAt: m.completedAt ? new Date(m.completedAt).toISOString() : null,
       createdAt: new Date(m.createdAt).toISOString(),
       updatedAt: new Date(m.updatedAt).toISOString(),
     }))

     return <DashboardOverview milestones={serializedMilestones} />
   }
   ```

   Implementation for DashboardOverview (client component):
   - Move ALL existing page.tsx content into `components/dashboard/dashboard-overview.tsx`
   - Accept `milestones` prop (serialized milestone data)
   - Parse ISO date strings back to Date objects on mount
   - Replace the hardcoded `mockData.milestones` with the real milestones prop for progress calculation
   - Keep all other mock data (analytics, documents, notifications, activities) as-is -- those are separate features
   - Use `calculateOverallProgress` with real milestones for the progress stat card

   IMPORTANT serialization note: Next.js cannot pass Date objects from server to client components. Dates must be serialized as ISO strings and parsed back on the client. The milestone type uses Date objects, so the client component needs to convert ISO strings back to Date.

   IMPORTANT: Do NOT change the visual design or layout of the dashboard. Only the data source changes.

   Files created/modified:
   - `app/dashboard/page.tsx` -- rewrite as server component
   - `components/dashboard/dashboard-overview.tsx` -- NEW, extracted client component
  </action>
  <verify>
- Run `npx tsc --noEmit` -- no type errors
- Run `npm run build` -- build succeeds
- Run `npm run dev` and visit /dashboard while logged in as client1@example.com
- Dashboard shows real progress percentage calculated from database milestones (not the old hardcoded 65%)
- Dashboard layout shows "Acme Accounting" as user name (from session)
  </verify>
  <done>
- Dashboard layout uses real session data for user display
- Dashboard overview page uses real milestones from DAL for progress calculation
- All other dashboard data (analytics, documents, etc.) remains as mock for now
- Visual design unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert progress page from mock data to DAL-powered server component</name>
  <files>app/dashboard/progress/page.tsx, components/dashboard/progress-view.tsx</files>
  <action>
Convert the progress page from a "use client" component with mock data to a server + client component architecture using real data from the DAL.

Approach:
1. Create a new server component at `app/dashboard/progress/page.tsx` that:
   - Imports `getMilestones` from `@/lib/dal`
   - Fetches milestones: `const milestones = await getMilestones()`
   - Serializes Date objects to ISO strings for client component transport
   - Passes serialized milestones to a client component

2. Extract the existing progress page UI into `components/dashboard/progress-view.tsx` as a "use client" component:
   - Move ALL the existing progress page content (hero card, stat cards, milestone checklist, delivery rhythm, status signals) into this component
   - Accept `milestones` as a prop (with ISO string dates)
   - On the client side, parse ISO strings back to Date objects to construct proper Milestone[] objects
   - Remove the hardcoded `mockMilestones` array
   - Keep `milestoneMeta` and `statusVisuals` as local constants (they're display config, not data)
   - The component should handle the case where milestones array is empty (show a "No milestones yet" state)

Server component (`app/dashboard/progress/page.tsx`):
```typescript
import { getMilestones } from "@/lib/dal"
import { ProgressView } from "@/components/dashboard/progress-view"

export default async function ProgressPage() {
  const milestones = await getMilestones()

  const serializedMilestones = milestones.map(m => ({
    ...m,
    startDate: m.startDate ? new Date(m.startDate).toISOString() : null,
    dueDate: m.dueDate ? new Date(m.dueDate).toISOString() : null,
    completedAt: m.completedAt ? new Date(m.completedAt).toISOString() : null,
    createdAt: new Date(m.createdAt).toISOString(),
    updatedAt: new Date(m.updatedAt).toISOString(),
  }))

  return <ProgressView milestones={serializedMilestones} />
}
```

Client component considerations:
- The `milestoneMeta` object maps milestone IDs to owner/focus. Since real milestones have CUID ids (not "kickoff", "funnels", etc.), this mapping won't work directly. Options:
  a. Map by milestone order instead of id (order 1 = first entry, order 2 = second, etc.)
  b. Map by title matching
  c. Remove the meta mapping and just show the milestone data as-is

  RECOMMENDED: Map by `order` field since the standard milestones have consistent ordering (1-6). Create a meta mapping keyed by order number. If a milestone order doesn't have a meta entry, use sensible defaults.

- Notes field from database comes as Json type. It should be cast to MilestoneNote[] array. If null or not an array, default to empty array.

- Empty state: If milestones is empty, show a card with message "No milestones assigned yet. Your project manager will set up your milestones during onboarding."

IMPORTANT: Preserve all existing visual design. Only the data source changes.
  </action>
  <verify>
- Run `npx tsc --noEmit` -- no type errors
- Run `npm run build` -- build succeeds
- Log in as client1@example.com, visit /dashboard/progress:
  - Should see 6 milestones (standard template)
  - First milestone shows as COMPLETED
  - Second milestone shows as IN_PROGRESS with 60% progress
  - Remaining milestones show as NOT_STARTED
- Log in as client2@example.com, visit /dashboard/progress:
  - Should see their own 6 milestones (all NOT_STARTED)
  - Should NOT see client1's progress
- Log in as admin@baseaim.com, visit /dashboard/progress:
  - Should see ALL milestones from both clients (12 total)
  </verify>
  <done>
- Progress page fetches real milestones from database via DAL
- Client users see only their own milestones
- Admin users see all milestones
- Empty state handled gracefully
- Visual design preserved
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete client data isolation: login page, DAL-powered dashboard and progress pages with real session data and client-scoped milestone queries</what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Ensure database is seeded: `npx prisma db seed`
3. Visit http://localhost:3000/dashboard -- should redirect to /login
4. Log in as client1@example.com / client123
5. Verify dashboard shows "Acme Accounting" as user name
6. Verify dashboard progress shows correct percentage based on real milestones
7. Navigate to Progress page -- verify 6 milestones with first COMPLETED and second IN_PROGRESS
8. Log out (or clear cookies), log in as client2@example.com / client123
9. Verify Progress page shows 6 milestones all NOT_STARTED (different from client1)
10. Log out, log in as admin@baseaim.com / admin123
11. Verify Progress page shows milestones from BOTH clients (12 total)
12. Visit /login while logged in -- should redirect to /dashboard
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with the auth flow or data isolation</resume-signal>
</task>

</tasks>

<verification>
- `npm run build` completes successfully
- Dashboard layout displays real user name from session
- Progress page uses DAL getMilestones() for data
- Client1 sees only their milestones
- Client2 sees only their milestones
- Admin sees all milestones
- Login page works for all three test accounts
</verification>

<success_criteria>
- Each client sees ONLY their own milestone data
- Admin sees ALL clients' milestone data
- Dashboard shows real user info from session
- No mock data remains in dashboard layout, dashboard overview milestones, or progress page milestones
- Login/logout flow works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/03-client-data-isolation/03-03-SUMMARY.md`
</output>
