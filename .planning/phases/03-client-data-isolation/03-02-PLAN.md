---
phase: 03-client-data-isolation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/login/page.tsx
  - prisma/seed.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "User can visit /login and see a login form with email and password fields"
    - "User can submit valid credentials and be redirected to /dashboard"
    - "User sees error message when submitting invalid credentials"
    - "Seed script creates an admin user, a client user with Client profile, and milestones for the client"
  artifacts:
    - path: "app/login/page.tsx"
      provides: "Login page with email/password form"
      contains: "signIn"
    - path: "prisma/seed.ts"
      provides: "Database seed script with admin user, client user, and milestones"
      contains: "bcrypt"
  key_links:
    - from: "app/login/page.tsx"
      to: "next-auth"
      via: "signIn('credentials', {...})"
      pattern: "signIn"
    - from: "prisma/seed.ts"
      to: "prisma/seed-milestones.ts"
      via: "import seedStandardMilestones"
      pattern: "seedStandardMilestones"
---

<objective>
Create the login page UI and a database seed script with test users so the auth flow can be tested end-to-end.

Purpose: Without a login page, users cannot authenticate. Without seed data, there are no users or milestones to test data isolation with. These two pieces enable manual testing of the complete auth flow.

Output: app/login/page.tsx (login form), prisma/seed.ts (test data seeder)
</objective>

<execution_context>
@C:\Users\eryde\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\eryde\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/auth.ts
@prisma/schema.prisma
@prisma/seed-milestones.ts
@app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create login page</name>
  <files>app/login/page.tsx</files>
  <action>
Create `app/login/page.tsx` as a client component with a login form:

Requirements:
- "use client" directive (needs useState, form handling)
- Email input (type="email", required)
- Password input (type="password", required)
- Submit button with loading state
- Error message display area
- Use signIn from "next-auth/react" with redirect: false to handle errors client-side
- On successful sign-in, redirect to /dashboard using router.push
- On failed sign-in, show "Invalid email or password" error
- Style with existing Tailwind/shadcn components (Card, CardHeader, CardContent, Input, Button, Label)
- Simple centered layout with BaseAim branding (just the text "BaseAim" as heading)
- No registration link needed (clients are created by admin/seed)

Implementation:
```typescript
"use client"

import { useState } from "react"
import { signIn } from "next-auth/react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"

export default function LoginPage() {
  const router = useRouter()
  const [error, setError] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    const formData = new FormData(e.currentTarget)
    const email = formData.get("email") as string
    const password = formData.get("password") as string

    const result = await signIn("credentials", {
      email,
      password,
      redirect: false,
    })

    if (result?.error) {
      setError("Invalid email or password")
      setIsLoading(false)
      return
    }

    router.push("/dashboard")
    router.refresh()
  }

  // return JSX with Card layout, form, inputs, error display, submit button
}
```

Styling notes:
- Center the card on screen: `min-h-screen flex items-center justify-center`
- Card max width: `w-full max-w-md`
- Use the existing fonts and color scheme (slate tones, primary accent)
- Error shown in a `<p>` with `text-sm text-red-500` class
- Loading state: button shows "Signing in..." and is disabled
- Keep it clean and minimal -- this is a B2B client portal, not a consumer app
  </action>
  <verify>
- Run `npx tsc --noEmit` -- no type errors
- Run `npm run build` -- login page compiles
- Manually verify: visit http://localhost:3000/login and see the login form
  </verify>
  <done>
- /login displays a centered card with email + password form
- Form handles submission with loading and error states
- Successful login redirects to /dashboard
- Invalid credentials show error message
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database seed script with test users and milestones</name>
  <files>prisma/seed.ts, package.json</files>
  <action>
Create `prisma/seed.ts` that seeds the database with test users and milestone data for verifying data isolation:

```typescript
import { PrismaClient } from "@prisma/client"
import bcrypt from "bcryptjs"
import { seedStandardMilestones } from "./seed-milestones"

const prisma = new PrismaClient()

async function main() {
  console.log("Seeding database...")

  // 1. Create admin user
  const adminPassword = await bcrypt.hash("admin123", 10)
  const admin = await prisma.user.upsert({
    where: { email: "admin@baseaim.com" },
    update: {},
    create: {
      email: "admin@baseaim.com",
      name: "BaseAim Admin",
      password: adminPassword,
      role: "ADMIN",
    },
  })
  console.log(`Admin user: ${admin.email}`)

  // 2. Create client user 1 (with Client profile and milestones)
  const client1Password = await bcrypt.hash("client123", 10)
  const client1User = await prisma.user.upsert({
    where: { email: "client1@example.com" },
    update: {},
    create: {
      email: "client1@example.com",
      name: "Acme Accounting",
      password: client1Password,
      role: "CLIENT",
      clientProfile: {
        create: {
          companyName: "Acme Accounting LLC",
          industry: "Accounting",
        },
      },
    },
    include: { clientProfile: true },
  })
  console.log(`Client 1: ${client1User.email}`)

  // Seed milestones for client 1 (only if none exist)
  if (client1User.clientProfile) {
    const existingMilestones = await prisma.milestone.count({
      where: { clientId: client1User.clientProfile.id },
    })
    if (existingMilestones === 0) {
      await seedStandardMilestones(client1User.clientProfile.id)
      console.log(`Milestones seeded for ${client1User.clientProfile.companyName}`)

      // Update some milestones to show progress for testing
      const milestones = await prisma.milestone.findMany({
        where: { clientId: client1User.clientProfile.id },
        orderBy: { order: "asc" },
      })

      if (milestones.length >= 3) {
        // Mark first milestone as completed
        await prisma.milestone.update({
          where: { id: milestones[0].id },
          data: {
            status: "COMPLETED",
            progress: 100,
            completedAt: new Date("2026-01-15"),
            startDate: new Date("2026-01-05"),
            dueDate: new Date("2026-01-15"),
            notes: [
              {
                id: "note-1",
                content: "Kickoff call completed. Goals and timelines aligned.",
                createdAt: new Date().toISOString(),
                createdBy: "BaseAim Admin",
              },
            ],
          },
        })

        // Mark second milestone as in progress
        await prisma.milestone.update({
          where: { id: milestones[1].id },
          data: {
            status: "IN_PROGRESS",
            progress: 60,
            startDate: new Date("2026-01-16"),
            dueDate: new Date("2026-02-01"),
            notes: [
              {
                id: "note-2",
                content: "Ad accounts connected. Configuring tracking pixels.",
                createdAt: new Date().toISOString(),
                createdBy: "BaseAim Admin",
              },
            ],
          },
        })
      }
    }
  }

  // 3. Create client user 2 (different client to test isolation)
  const client2Password = await bcrypt.hash("client123", 10)
  const client2User = await prisma.user.upsert({
    where: { email: "client2@example.com" },
    update: {},
    create: {
      email: "client2@example.com",
      name: "Smith & Partners",
      password: client2Password,
      role: "CLIENT",
      clientProfile: {
        create: {
          companyName: "Smith & Partners CPA",
          industry: "Accounting",
        },
      },
    },
    include: { clientProfile: true },
  })
  console.log(`Client 2: ${client2User.email}`)

  // Seed milestones for client 2 (different progress state)
  if (client2User.clientProfile) {
    const existingMilestones = await prisma.milestone.count({
      where: { clientId: client2User.clientProfile.id },
    })
    if (existingMilestones === 0) {
      await seedStandardMilestones(client2User.clientProfile.id)
      console.log(`Milestones seeded for ${client2User.clientProfile.companyName}`)
    }
  }

  console.log("\nSeed complete!")
  console.log("\nTest credentials:")
  console.log("  Admin:    admin@baseaim.com / admin123")
  console.log("  Client 1: client1@example.com / client123")
  console.log("  Client 2: client2@example.com / client123")
}

main()
  .catch((e) => {
    console.error(e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

Also add the prisma seed command to package.json:
- Add `"prisma": { "seed": "npx tsx prisma/seed.ts" }` to package.json root level
- Install tsx as devDependency if not present: `npm install -D tsx`

Key design decisions:
- Use `upsert` so the seed is idempotent (can run multiple times safely)
- Two client users to test isolation (client1 sees only their milestones, not client2's)
- Client 1 has progress (milestones 1 completed, 2 in progress) for realistic testing
- Client 2 has default milestones (all NOT_STARTED) for contrast
- Admin user has no Client profile (role ADMIN, sees all)
- Passwords are simple for development only
  </action>
  <verify>
- Run `npx tsc --noEmit` -- seed script compiles without errors
- Run `npx prisma db push` to ensure schema is synced
- Run `npx prisma db seed` -- completes without errors, prints credentials
- Run `npx prisma db seed` again -- completes idempotently without duplicate errors
  </verify>
  <done>
- prisma/seed.ts creates admin user, 2 client users with profiles, and milestones
- Seed is idempotent (upsert pattern)
- Client 1 has varied milestone progress for realistic testing
- Client 2 has fresh milestones (all NOT_STARTED)
- `npx prisma db seed` command works via package.json config
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes successfully
- /login page renders in the browser
- `npx prisma db seed` creates test data without errors
- Can log in as admin@baseaim.com with admin123
- Can log in as client1@example.com with client123
</verification>

<success_criteria>
- Login page exists at /login with working form
- Three test users seeded (1 admin, 2 clients)
- Each client has their own set of milestones
- Login redirects to /dashboard on success
- Invalid credentials show error on login page
</success_criteria>

<output>
After completion, create `.planning/phases/03-client-data-isolation/03-02-SUMMARY.md`
</output>
