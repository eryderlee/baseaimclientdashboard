---
phase: 05-client-onboarding-and-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/schemas/client.ts
  - app/admin/actions.ts
  - lib/dal.ts
  - lib/utils/password.ts
  - app/layout.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "Admin cannot create a client with invalid email, short password, or missing required fields"
    - "Creating a client either fully succeeds (user + client + 6 milestones) or fully fails with no partial data"
    - "Admin can update client details and changes persist after page refresh"
    - "Admin can toggle a client between active and inactive status"
    - "Edit form loads with the current client information pre-filled"
    - "Toast notifications appear after successful or failed actions"
  artifacts:
    - path: "lib/schemas/client.ts"
      provides: "Zod schemas for createClient and updateClient"
      exports: ["createClientSchema", "updateClientSchema", "CreateClientInput", "UpdateClientInput"]
    - path: "app/admin/actions.ts"
      provides: "Server Actions for client CRUD"
      exports: ["createClient", "updateClient", "toggleClientStatus"]
    - path: "lib/dal.ts"
      provides: "getClientForEdit DAL function"
      exports: ["getClientForEdit"]
    - path: "lib/utils/password.ts"
      provides: "Secure password generation utility"
      exports: ["generateSecurePassword"]
    - path: "app/layout.tsx"
      provides: "Sonner Toaster mounted in root layout"
      contains: "Toaster"
  key_links:
    - from: "app/admin/actions.ts"
      to: "lib/schemas/client.ts"
      via: "import createClientSchema, updateClientSchema"
      pattern: "import.*from.*schemas/client"
    - from: "app/admin/actions.ts"
      to: "prisma.$transaction"
      via: "atomic User+Client+Milestone creation"
      pattern: "prisma\\.\\$transaction"
    - from: "app/admin/actions.ts"
      to: "lib/utils/progress"
      via: "reuses STANDARD_MILESTONES template"
      pattern: "STANDARD_MILESTONES"
---

<objective>
Create the backend foundation for client onboarding: Zod validation schemas, Server Actions for client CRUD (create with atomic transaction, update, toggle status), DAL query for edit page, password generation utility, and Sonner toast infrastructure.

Purpose: All client management UI in subsequent plans depends on validated schemas, working Server Actions, and toast feedback. Building backend first ensures UI plans can wire directly to tested actions.
Output: Validation schemas, 3 Server Actions, 1 DAL function, password utility, Toaster in layout.
</objective>

<execution_context>
@C:\Users\eryde\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\eryde\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-client-onboarding-and-management/05-RESEARCH.md
@prisma/schema.prisma
@prisma/seed-milestones.ts
@lib/dal.ts
@app/admin/clients/[clientId]/actions.ts
@app/layout.tsx
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, add Toaster, create Zod schemas and password utility</name>
  <files>
    package.json
    app/layout.tsx
    lib/schemas/client.ts
    lib/utils/password.ts
  </files>
  <action>
    1. Install dependencies:
       ```
       npm install react-hook-form @hookform/resolvers sonner
       ```

    2. Add Sonner Toaster to `app/layout.tsx`:
       - Import `{ Toaster }` from `'sonner'`
       - Add `<Toaster position="top-right" />` inside `<body>` after `{children}`

    3. Create `lib/schemas/client.ts` with two Zod schemas:

       **createClientSchema:**
       - `name`: string, min 2 chars ("Name must be at least 2 characters")
       - `email`: string, email format ("Enter a valid email address")
       - `password`: string, min 8 chars ("Password must be at least 8 characters")
       - `companyName`: string, min 2 chars ("Company name is required")
       - `industry`: string, optional
       - `website`: string, url format, optional, OR empty string (use `.or(z.literal(''))`)
       - `phone`: string, optional
       - `address`: string, optional

       **updateClientSchema:**
       - Same fields as createClientSchema EXCEPT: no password field, no email field
       - `name`: string, min 2 chars
       - `companyName`: string, min 2 chars
       - `industry`, `website`, `phone`, `address`: same optionals

       Export both schemas and their inferred types (`CreateClientInput`, `UpdateClientInput`).

    4. Create `lib/utils/password.ts`:
       - Export `generateSecurePassword(length: number = 12): string`
       - Must include at least one lowercase, uppercase, digit, and symbol (!@#$%^&*)
       - Fill remaining chars from combined charset
       - Use `crypto.getRandomValues` for ALL randomness -- do NOT use `Math.random` anywhere in this file

       **Secure random implementation pattern:**
       ```typescript
       // Helper: get a cryptographically secure random integer in [0, max)
       function secureRandomInt(max: number): number {
         const array = new Uint32Array(1)
         crypto.getRandomValues(array)
         return array[0] % max
       }
       ```
       Use this helper for both character selection (picking random chars from charset) and for Fisher-Yates shuffle.

       **Fisher-Yates shuffle (secure):**
       ```typescript
       for (let i = result.length - 1; i > 0; i--) {
         const j = secureRandomInt(i + 1);
         [result[i], result[j]] = [result[j], result[i]]
       }
       ```

       IMPORTANT: The RESEARCH.md example code uses `Math.random()` -- do NOT follow that pattern. It is insecure. Use the `crypto.getRandomValues` approach shown above.
  </action>
  <verify>
    - `npm ls react-hook-form @hookform/resolvers sonner` shows installed packages
    - `npx tsc --noEmit` passes with no type errors in new files
    - Grep password utility to confirm no Math.random usage: `grep -c "Math.random" lib/utils/password.ts` returns 0
    - Grep password utility to confirm crypto usage: `grep -c "crypto.getRandomValues" lib/utils/password.ts` returns at least 1
  </verify>
  <done>
    - Sonner Toaster renders in root layout
    - createClientSchema and updateClientSchema export valid Zod schemas with proper error messages
    - generateSecurePassword produces 12-char passwords with all character classes using crypto.getRandomValues (not Math.random)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Server Actions and DAL function for client management</name>
  <files>
    app/admin/actions.ts
    lib/dal.ts
  </files>
  <action>
    1. Create `app/admin/actions.ts` with `'use server'` directive containing three Server Actions:

       **createClient(formData: FormData):**
       - Verify admin role via `verifySession()`, return `{ error: 'Unauthorized' }` if not admin
       - Extract fields from FormData and validate with `createClientSchema.safeParse()`
       - Return `{ error: 'Validation failed', errors: fieldErrors }` if invalid
       - Check for existing user by email via `prisma.user.findUnique({ where: { email } })`
       - Return `{ error: 'A user with this email already exists' }` if found
       - Hash password with `bcrypt.hash(password, 10)` BEFORE the transaction (avoid slow ops inside tx)
       - Use `prisma.$transaction(async (tx) => { ... })` to atomically:
         a. `tx.user.create()` with email, name, hashedPassword, role: 'CLIENT'
         b. `tx.client.create()` with userId, companyName, industry, website, phone, address, isActive: true
         c. Create 6 milestones using STANDARD_MILESTONES array from `@/prisma/seed-milestones` -- map over STANDARD_MILESTONES and call `tx.milestone.create()` for each with clientId, title, description, order, status, progress, dueDate, notes
       - After transaction: `revalidatePath('/admin')` and `redirect('/admin')`
       - Wrap in try/catch, return `{ error: 'Failed to create client. Please try again.' }` on failure

       CRITICAL: Do NOT import the `seedStandardMilestones` function from seed-milestones (it creates its own PrismaClient instance which would deadlock inside a transaction). Import ONLY the `STANDARD_MILESTONES` array and create milestones manually using the `tx` transaction client.

       CRITICAL: The `bcrypt.hash()` call MUST appear BEFORE `prisma.$transaction()` -- not inside the transaction callback. This avoids holding the transaction open during a slow CPU-bound operation. The code structure must be:
       ```
       const hashedPassword = await bcrypt.hash(password, 10)
       await prisma.$transaction(async (tx) => {
         // use hashedPassword here, do NOT call bcrypt inside this block
       })
       ```

       **updateClient(clientId: string, formData: FormData):**
       - Verify admin role
       - Extract and validate with `updateClientSchema.safeParse()`
       - `prisma.client.update({ where: { id: clientId }, data: validatedFields.data })`
       - Also update user name: `prisma.user.update({ where: { id: client.userId }, data: { name } })`
       - Use a transaction for both updates
       - `revalidatePath('/admin')` and `revalidatePath('/admin/clients/${clientId}/edit')`
       - Return `{ success: true }` or `{ error: string }`

       **toggleClientStatus(clientId: string):**
       - Verify admin role
       - Fetch current client: `prisma.client.findUnique({ where: { id: clientId }, select: { isActive: true } })`
       - Toggle: `prisma.client.update({ where: { id: clientId }, data: { isActive: !current.isActive } })`
       - `revalidatePath('/admin')`
       - Return `{ success: true, isActive: !current.isActive }` or `{ error: string }`

    2. Add `getClientForEdit` to `lib/dal.ts`:
       - Wrap with `cache()`
       - Verify admin role via `verifySession()`
       - Query: `prisma.client.findUnique({ where: { id: clientId }, include: { user: { select: { name, email } } } })`
       - Throw error if not found
       - Return client with user details
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - All three Server Actions are exported from `app/admin/actions.ts`
    - `getClientForEdit` is exported from `lib/dal.ts`
    - Verify bcrypt.hash is BEFORE transaction: `grep -n "bcrypt.hash\|\\$transaction" app/admin/actions.ts` -- bcrypt.hash line number must be LESS than $transaction line number
    - Verify STANDARD_MILESTONES import (not seedStandardMilestones): `grep "seedStandardMilestones" app/admin/actions.ts` returns no matches
  </verify>
  <done>
    - createClient atomically creates User + Client + 6 milestones in one transaction
    - bcrypt.hash is called BEFORE the transaction, not inside it
    - Only STANDARD_MILESTONES array is imported (not the seedStandardMilestones function)
    - updateClient updates client details and user name
    - toggleClientStatus flips isActive boolean
    - getClientForEdit returns client with user info for edit form
    - All actions validate input with Zod and verify admin role
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `npm ls react-hook-form @hookform/resolvers sonner` shows all three packages installed
- All exports exist: createClientSchema, updateClientSchema, CreateClientInput, UpdateClientInput, createClient, updateClient, toggleClientStatus, getClientForEdit, generateSecurePassword
- No `Math.random` in password.ts, no `seedStandardMilestones` import in actions.ts
- bcrypt.hash called before $transaction in actions.ts
</verification>

<success_criteria>
- Three Server Actions handle create/update/toggle with proper validation and error handling
- Client creation uses Prisma $transaction for atomic User+Client+Milestones creation
- Password hashing happens BEFORE transaction (not inside)
- Password generation uses crypto.getRandomValues (not Math.random)
- Zod schemas provide clear validation messages for form fields
- Sonner Toaster is mounted and ready for toast notifications
</success_criteria>

<output>
After completion, create `.planning/phases/05-client-onboarding-and-management/05-01-SUMMARY.md`
</output>
